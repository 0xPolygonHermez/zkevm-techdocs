\section{Introduction}

Since the term was coined and the first example was given in 1985 by Goldwasser et al. \cite{STOC:GolMicRac85}, \textit{probabilistic proofs} leverages a set of protocols, such as \textit{Interactive Proofs (IPs)} \cite{STOC:GolMicRac85} and Probabilistic Checkable Proofs \cite{FOCS:AroSaf92}, that enable one party, known as the \textit{prover}, to provide a guarantee to another party, known as the \textit{verifier}, that the former performed a computation requested by the latter correctly. In practical terms, probabilistic proofs enable a computationally weak device to monitor the execution of a powerful but \textit{untrusted} powerful server, allowing it to outsource a program execution to the server.

Probabilistic proofs can be even more useful when they also possess a property known as \textit{zero-knowledge} \cite{STOC:GolMicRac85}, which intuitively means that the proof reveals nothing but its validity. Equipped with zero-knowledge, probabilistic proofs let the prover demonstrate knowledge of a secret input satisfying a certain statement without revealing any information about the input beyond the validity of the statement. For example, a probabilistic proof satisfying zero-knowledge can be used to prove possession of a secret key associated with a particular public key or the knowledge of the preimage of a particular hash digest; without revealing any information about the secret key or the preimage. The latter could be used to log in to a website without typing a password, by simply sending proof of possession of the valid password.

Slightly more formal, our scenario is one in which the verifier, denoted as $\V$, sends a program description $f$ and an input $x$ for that program to the prover, denoted as $\P$. Then, $\P$ computes and returns the execution of program $f$ on input $x$, i.e., $y = f(x)$, along with a proof $\pi$ that the output $y$ is correct and consistent with the description $f$ and the input $x$. The proof $\pi$ should satisfy the following properties:
\begin{itemize}
	\item \textbf{Completeness}. If $\P$ is honest, which means that he knows a pair $(x,y)$ such that the claim $f(x) = y$ is true and follows the protocol properly, then $\P$ should be able to compute a proof that convinces the verifier $\V$ of the validity of the claim.

	\item \textbf{Soundness}. A malicious prover $\P^*$ should be able to produce a proof that convinces the verifier $\V$ of a statement of a false claim, i.e., that $f(x) \neq y$, with negligible probability.
\end{itemize}
Completeness means that an honest verifier will always accept a proof if it is generated by an honest prover. Soundness deals with the verifier not accepting false proofs from malicious provers. These two properties protect the verifier against malicious provers. Moreover, the verification of the proof $\pi$ should be much more efficient than rerunning the program $f$ on $x$.

To also make probabilistic proofs privacy-preserving, $\P$ can provide his private input $w$ to the computation, known as the \textit{witness}. Thus, $f$ now is written as a function of two inputs $(x,w)$ such that $f(x,w) = y$. If at the end of the protocol, $\V$ is convinced that the statement $y = f(x,w)$ is true without learning anything about $w$, then the scheme satisfies the zero-knowledge property and is typically called a \textit{Zero-Knowledge Proof (ZKP)}.

More formally, a ZKP satisfies completeness, soundness and zero-knowledge defined as follows:
\begin{itemize}
	\item \textbf{Zero-Knowledge}: After interacting with $\P$ about the claim $f(x,w) = y$, $\V$ should learn nothing about the witness $w$ and still be convinced of the validity of the claim.
\end{itemize}
Compared with completeness and soundness, the zero-knowledge property guarantees the privacy of the prover's secret information against malicious verifiers.


\paragraph*{zk-SNARKs.}
One family of ZKPs that has become of important consideration in recent years both in theory and in practice are \textit{zero-knowledge Succinct Non-interactive ARguments of Knowledge (zk-SNARKs)} \cite{EPRINT:BCCT11}. At a high level, zk-SNARKs is a generic term to refer to ZKPs whose cryptographic assumptions and computational complexity are reasonable for practical use. More specifically, the acronym zk-SNARKs refers to probabilistic proofs such that:
\begin{itemize}
	\item \textbf{zk}: Satisfy the zero-knowledge property, even though it is optional.
	\item \textbf{Succinct}: Have size sublinear compared to the size of the statement or the witness, i.e., the size of the computation itself.
	\item \textbf{Non-Interactive}: Do not require rounds of interaction between a particular prover and verifier and are publicly verifiable.
	\item \textbf{Argument}: Assume that are generated by provers having at most polynomial computational resources. In particular, provers are not able to break standard cryptographic assumptions.
	\item \textbf{Of Knowledge}: Satisfy \textit{knowledge soundness} rather than plain \textit{soundness}. That is, the proof demonstrates that the prover \textit{owns} a witness for the statement, not only its existence.
\end{itemize}

In the literature it can be found many examples of zk-SNARKs \cite{EPRINT:Groth16}, \cite{SP:BBBPWM18}, \cite{EPRINT:GabWilCio19}, \cite{EPRINT:CHMMVW19}, each of them based on distinct cryptographic primitives and coming with different tradeoffs.

An application that makes use of zk-SNARKs as its core technology is Zcash \cite{Wilcox2016ZcashPS}, a public blockchain based on bitcoin that uses these proofs in its core protocol for verifying that private transactions, named \textit{shielded} transactions, have been computed correctly while revealing anything else to an external observer. 
% In particular, a shielded transaction can be verified without revealing the payment source, destination, or amount, but still ensuring that there are enough funds to do it, and that the transfer is sent by the owner of the funds.
More applications range from using zk-SNARKs to fight disinformation \cite{Yi2022}, to using zk-SNARKs for proving that convolutional neural networks have made predictions correctly without revealing the model itself \cite{EPRINT:LiuXieZha21}.


\paragraph*{zk-STARKs.}
Although zk-SNARKs have numerous applications, they suffer from a severe limitation: the requirement of a trusted party that generates random public parameters, known as the \textit{trusted setup}, for the system to work that eliminates any knowledge of the randomness used in the process (typically known as the \textit{toxic waste}). In fact, if a malicious party obtains access to that toxic waste then this party can easily forge false proofs.

As a result, systems that remove the previous requirement, and are therefore of \textit{transparent} nature, have been developed. The most prominent family of transparent ZKPs are \textit{zero-knowledge Scalable Transparent ARguments of Knowledge (zk-STARKs)} \cite{EPRINT:BBHR18}. Apart from satisfying the same properties of a zk-SNARKs, zk-STARKs are required to satisfy two additional properties:
\begin{itemize}
	\item \textbf{Scalability}. Proving time is at most quasilinear and verification time is at most logarithmic in the size of the statement. 

	\item \textbf{Transparency}. They do not require any trusted setup, i.e., any randomness used by transparent frameworks are public coins.
\end{itemize}

Examples of zk-STARKs are also present in the literature \cite{EPRINT:WTsTW17}, \cite{EPRINT:ChiOjhSpo19}, \cite{EPRINT:Setty19}.

\paragraph*{Intermediate Representations.}
Given a program $f$, to compute a proof of the validity of the execution of $f$, we typically agree upon an equivalent model amenable to probabilistic proof and then express $f$ as an algebraic constraint satisfaction problem of that model. This latter step is often called \textit{arithmetization}, the output of such being an \textit{intermediate representation}. For instance, (unstructured) arithmetic circuits are often encoded as a system of quadratic equations over a finite field known as \textit{Rank-1 Constraint System (R1CS)}. In contrast, ``structured'' arithmetic circuits are often encoded as a set of repeated polynomial computations known as \textit{Algebraic Intermediate Representation (AIR)}. Here, by structured we are referring to circuits that are designed with a layered architecture, where each layer contains a small circuit that is replicated in every layer. In fact, an AIR is the standard intermediate representation consumed by a STARK \cite{EPRINT:StarkWare21}.

Since we will be dealing with structured arithmetic circuits, let us introduce an AIR more formally. An AIR $\AIR$ over a field $\FF$ is defined by a set of multivariate constraint polynomials $C_i \in \FF[X_1,\dots, X_{2M}]$. The idea is that $f$, represented as a set of univariate polynomials $p_1,\dots,p_{2M} \in \FF[X]$, will be said to satisfy $\AIR$ if and only if the following polynomial constraints:
\[
C_i(p_1(X),\dots, p_{2M}(X)) = 0,
\]
are satisfied over a subset of $\FF$. Therefore, we translate the computation of $f$ into the satisfaction of every polynomial $C_i$ of an (equivalent) AIR $\AIR$, being the latter ready to be consumed by an appropriate STARK. 

Note that the definition of an AIR only captures polynomial constraints defined through equality. So, for instance, we are not able to directly express that the evaluations of a polynomial over the given subset are lower than a predetermined upper bound. For this, we would need to express this inequality as a set of equality with the incorporation of new polynomials such that the new constraints satisfy the equality if and only if the inequality is satisfied.

In this paper, we enlarge the type of constraints that can be captured by an AIR with the addition of non-identity constraints satisfying some requirements. We call the resulting constraint system an \textit{extended AIR (eAIR)}. Details will be explained in Section \ref{sec:eAIR}. Moreover, we provide a particular probabilistic proof that is ready to consume an eAIR, and because it will be defined as a generalization of a STARK, we will refer to it as an \textit{extended STARK (eSTARK)}.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Organization}

This paper is organized as follows. In Section \ref{sec:preliminaries} we recall basic definitions related to the IOP model, introduce the non-identity constraints from which we enlarge the AIR expressiveness and provide an in-depth overview of STARKs. Moreover, we explain the low-degree test FRI that will be later on used by our eSTARK. In Section \ref{sec:our-techniques} we not only exhibit the main differences between STARKs and our eSTARK, but we also explain how to introduce the new type of constraints into the STARK protocol. We put everything together in Section \ref{sec:generic-description} and proof that the eSTARK protocol is sound. Moreover, in Section \ref{sec:STIK-to-STARK} we provide a full description of our eSTARK in the practical realm. We conclude in Section \ref{sec:conclusions}.