\section{The ROM}
As explained above, the ROM is a zkASM program that can be executed by a  "special" virtual machine and allows to execute Polygon L2 State transitions with CI by inheriting Ethereum L1 security. This section aims to provide a detailed description of the ROM, allowing for a better understanding of its operation. The code of the ROM found at \href[]{https://github.com/0xPolygonHermez/zkevm-rom}{0xPolygonHermez/zkevm-rom} GitHub repository.


\subsection{ROM executions public parameters}

To achieve CI of a specific ROM execution, the resulting proof generated by the zkEVM batch prover must be successfully verified by L1 contracts. However, a zero-knowledge proof does not reveal any information about the specific computation being verified. Therefore, to allow the L1 smart to verify that a specific CI proofs corresponds to a specific state transition, a few "public" parameters of the computation are disclosed. The L1 verifier contract will verify the proof using this parameters and the verification will succeed only if the public parameters are those ones used to generate the proof by the prover. The disclosure of these parameters ensures that the proof being verified corresponds to a specific state transition, meaning that the execution of a specific batch over a specific state leads to a specific new state. L1 contracts provide data availability of the L2 batches, so that the prover is bound to on-chain data to fill the public parameters and generate a valid CI proof, and the verifier can access that data in a trustless manner during the proof verification.

The verification will succeed only if the public parameters match to those used to generate the CI proof by the prover. Each of the public parameters is listed and detailed below:


\begin{itemize}
    \item \textbf{oldStateRoot:} L2 State Merkle Root of the L2 State before the state transition that wants to be proven. Ensures the integrity of the old L2 State on which transactions are executed.
    \item \textbf{oldAccInputHash:} Unique cryptographic identifier of the previous batch in the batch chain, the batch whose execution led to the L2 state before the state transition that wants to be proven, ensures the correct position of the state transaction in the batches sequence.
    \item \textbf{oldBatchNum:} Unique batch index of the previous batch, the batch whose execution led to the L2 state before the state transition that wants to be proven.
    \item \textbf{newStateRoot:} L2 State Merkle Root of the L2 State after the state transition that wants to be proven. Ensures the integrity of the old L2 State that results of the state transition.
    \item \textbf{newAccInputHash:} Unique cryptographic identifier of the batch whose execution is being proved, ensures the integrity of the batch.
    \item \textbf{newBatchNum:} Unique batch index of the the batch whose execution is being proved.
    \item \textbf{localExitRoot:} L2 Bridge contract's Exit Merkle Tree(EMT) at the end of the batch execution, ensures the integrity of the bridging transactions going out form the L2. 
    \item \textbf{chainID:} Unique chain ID of Polygon zkEVM network, ensures that the computation can only be proven for a specific network.
    \item \textbf{forkID:} Unique identifier of the version of the ROM being used, ensures that the computation can only be proven for a specific version of the ROM code.
\end{itemize}

\subsection{ROM main.zkasm}
The  \href[]{https://github.com/0xPolygonHermez/zkevm-rom/blob/main/main/main.zkasm}{main.zkasm} is the zkASM code of the ROM where the batch processing and execution is described. The entry point of the ROM is represented by the \textbf{start} instruction. 

ROM's main.zkasm code is divided in the following 6 sections:
\begin{itemize}
    \item \textbf{A}: Load initial registers into memory.
    \item \textbf{B}: Set batch global variables.
    \item \textbf{C}: Loop parsing RLP transactions.
    \item \textbf{D}: Loop processing transactions.
    \item \textbf{E}: Batch asserts \& computations:.
    \item \textbf{F}: Finalize execution.
\end{itemize}

\subsubsection{A: Load initial registers into memory}

The ROM code describes a general computation to process and execute a batch of L2 transactions, but the specific batch to process must be given as well as all the values that can vary between different ROM executions. We refer to these values as ROM's input variables.

In the first lines of the ROM, all those inputs are loaded into the memory to be used later. Note that each input has a proper memory variable to be stored.


\begin{zkasm}
    STEP => A
    0                                   :ASSERT ; Ensure it is the beginning of the execution
    
    CTX                                 :MSTORE(forkID)
    CTX - %FORK_ID                      :JMPNZ(failAssert)
    
    B                                   :MSTORE(oldStateRoot)
    C                                   :MSTORE(oldAccInputHash)
    SP                                  :MSTORE(oldNumBatch)
    GAS                                 :MSTORE(chainID)
    
    ${getGlobalExitRoot()}              :MSTORE(globalExitRoot)
    ${getSequencerAddr()}               :MSTORE(sequencerAddr)
    ${getTimestamp()}                   :MSTORE(timestamp)
    ${getTxsLen()}                      :MSTORE(batchL2DataLength) ; less than 300.000 bytes. Enforced by the smart contract
    
    B => SR ;set initial state root
    
    ; Increase batch number
    SP + 1                              :MSTORE(newNumBatch)
\end{zkasm}

The first four lines ensure that this fragment of code is only executed at the beginning of the execution, i.e. they asserts that the \textbf{STEP} register is equal to 0, and that the version of the rom is correct, i.e ensures that the ROM's constant \textbf{FORK\_ID} equals to the \textbf{frok\_id} input variable. The following lines store the values of the input variables in memory variables. Note that most of them correspond to the execution's public parameters.

\subsubsection{B: Set batch gobal variables}

Batches are stored in Ethereum L1 following a specific data structure. The ROM uses the values in that data structure to identify the batch and ensure its integrity (refer to the technical documents regarding zkEVM state management to lean about batch data structure). The next section of the main.zkasm will load the batch data in the memory to be used later.

In the next three lines, the program will verify whether \textbf{globalExitRoot} is equal to 0. If it is, the execution flow will jump to the \textbf{skipSetGlobalExitRoot} line in the ROM. Note that the program first loads the value of \textbf{globalExitRoot} into register A and the value of 0 into register B before executing the combination of \textbf{EQ} and \textbf{JMPC(skipSetGlobalExitRoot)} instructions. The \textbf{EQ} instruction checks if A is equal to B, and if it is, the program flow will jump accordingly.

\begin{zkasm}
    $${eventLog(onStartBatch, C)}
    
    $ => A                                  :MLOAD(globalExitRoot)
    0 => B
    $                                       :EQ, JMPC(skipSetGlobalExitRoot)
    
\end{zkasm}

The section of main.zkasm shown below stores the \textbf{GlobalExitRoot} value in the \textbf{globalExitRootMap} of the \textbf{PolygonZkEVMGlobalExitRootL2.sol} contract instance, which allows users to claim bridged assets in L2 (refer to the technical documents regarding the zkEVM bridge). 0 is not a valid value for a \textbf{GlobalExitRoot}, therefore in this case, the previously explained jump will be executed and this part will be skipped. \textbf{globalExitRootMap} mapping entries has \textbf{GlobalExitRoot} as keys and the batch's timestamp as values.

\begin{zkasm}
    setGlobalExitRoot:
    0 => HASHPOS
    $ => E                                  :MLOAD(lastHashKIdUsed)
    E+1 => E                                :MSTORE(lastHashKIdUsed)
    
    32 => D
    A                                       :HASHK(E)
    %GLOBAL_EXIT_ROOT_STORAGE_POS           :HASHK(E) ; Storage position of the global exit root map
    HASHPOS                                 :HASHKLEN(E)
    $ => C                                  :HASHKDIGEST(E)
    
    %ADDRESS_GLOBAL_EXIT_ROOT_MANAGER_L2 => A
    %SMT_KEY_SC_STORAGE => B
    
    ; read timestamp given the globalExitRoot
    ; skip overwrite timestamp if it is different than 0
    ; Since timestamp is enforced by the smart contract it is safe to compare only 32 bits in 'op0' with JMPNZ
    $ => D                                  :SLOAD, JMPNZ(skipSetGlobalExitRoot)
    
    $ => D                                  :MLOAD(timestamp)
    $ => SR                                 :SSTORE ; Store 'timestamp' in storage position 'keccak256(globalExitRoot, 0)'
\end{zkasm}

Let's analyze the lines above in depth. Specific Solidity mapping values are stored in a specific contract storage slot computed as Keccak("key", "mapping slot"). Therefore, in order to compute the storage slot where the timestamp of a specific \textbf{globalExitRoot} will be stored, it is mandatory to perform a Keccak hash operation.

The first four lines are a consequence of how the hashes are performed in zkASM. First, the \textbf{HASPOS} register is set to zero in order to set the pointer of the hashing input array to its 0 position. Then, the \textbf{lastHashKIdUsed} memory variable is loaded into register E and incremented by one. \textbf{lastHashKIdUsed} contains the index of the last hash operation performed, therefore our hash operation will be next to it and the new value of register \textbf{E} will be used as its index.

The goal of line 6 is to set the length in bytes of the next entry in the hash input array that will be taken, by design from the register \textbf{D}. In this case, since both Keccak arguments are 32 bytes in length, the number 32 is set. In the following two lines, the two Keccak arguments are loaded into the hash inputs array: first, the \textbf{GlobalExitRoot} that was already in the \textbf{A} register, and then the slot address of the mapping in the contract's storage. Then, in line 9, the computation of the hash is triggered by giving \textbf{HASHPOS} as the length of the hash input array. Note that \textbf{HASHPOS} will be 64 since it auto-increments its value each time a byte is pushed into the hash input array via \textbf{HASHK} instruction, and we have pushed 32 bytes of \textbf{GlobalExitRoot} and 32 bytes of the slot address. In the following line the hash digest will be loaded to register C.

Next, in lines 12 and 13, the address of the \textbf{PolygonZkEVMGlobalExitRootL2.sol} contract instance and the type of Polygon zkEVM's state tree leaf that will contain the mapping value (3-Contract storage slot value) will be loaded into registers A and B, respectively. Note that at this moment, zkASM storage operations can be performed on the zkEVM state tree leaf that holds the 32-byte storage slot that corresponds to the value of the specific \textbf{GlobalExitRoot} in the mapping \textbf{globalExitRootMap} of the \textbf{PolygonZkEVMGlobalExitRootL2.sol} contract instance.

Line 18 will check if the storage slot is already set, i.e., if it is different from zero, and will skip lines 20 and 21 in that case to avoid overwriting a \textbf{GlobalExitRoot} that has already been set. Lines 20 and 21 will load the timestamp value from the memory variable to register D and then store it with the \textbf{SSTORE} instruction. Note that the \textbf{SR} is also updated with the latest Polygon zkEVM's state root value in the line 21.

The following 8 lines will save the previously computed state tree root to the memory variable batchSR. Then, they will load the number index of the last transaction executed in the L2 from the leaf that contains it in the state tree, and store it in the \textbf{txCount} memory variable.
\begin{zkasm}
    skipSetGlobalExitRoot:
    SR                                      :MSTORE(batchSR)
    ; Load current tx count
    %LAST_TX_STORAGE_POS => C
    %ADDRESS_SYSTEM => A
    %SMT_KEY_SC_STORAGE => B
    $ => D          :SLOAD
    D               :MSTORE(txCount)
\end{zkasm}

TODO: EXPLAIN WHY MUST BE CHECKED THE KECCAK COUNTERS.

%%> Jesus Polygon:
%%Yep la idea es "demostrar" Que no tienes suficientes counters %%para seguir la ejecución
%%Y en ese caso, hacer las comprobaciones minimas y acabar la %%ejecución


\begin{zkasm}
    
    ; Compute necessary keccak counters to finish batch
    $ => A          :MLOAD(batchL2DataLength)
    ; Divide the total data length + 1 by 136 to obtain the keccak counter increment.
    ; 136 is the value used by the prover to increment keccak counters
    A + 1                                   :MSTORE(arithA)
    136                                     :MSTORE(arithB), CALL(divARITH); in: [arithA, arithB] out: [arithRes1: arithA/arithB, arithRes2: arithA%arithB]
    $ => B                                  :MLOAD(arithRes1)
    ; Compute minimum necessary keccaks to finish the batch
    B + 1 + %MIN_CNT_KECCAK_BATCH => B      :MSTORE(cntKeccakPreProcess)
    %MAX_CNT_KECCAK_F - CNT_KECCAK_F - B    :JMPN(handleOOCKatRLP)
\end{zkasm}



\subsubsection{C: Loop parsing RLP transactions}


In a batch, the transactions are represented as a byte array where each transaction is encoded using the Ethereum pre-EIP-115 or EIP-115 formats and following the RLP (Recursive-length prefix) standard. The encoded transaction is concatenated with the values v, r, and s of the signature. The section of main.zkasm that follows iterates through each transaction in the batch. For each transaction, a new zkasm memory context is created and the transaction data is parsed to extract the transaction values which are stored in memory variables for later use. Also each transaction data will be pushed to an specific keccak operation given by batchHashDataId  input buffer. The hash digest of all transaction data is used to calculate the accumulated hash of the batch in question.

The transactions must have one of the following structure:
\begin{itemize}
    \item EIP-155: rlp(nonce, gasprice, g asLimit, to, value, data, chainid, 0, 0,)vrs.
    \item pre-EIP-155: rlp(nonce, gasprice, gasLimit, to, value, data)vrs.
\end{itemize}



\begin{zkasm}
    E+1 => E                            :MSTORE(lastHashKIdUsed)
    0                                   :MSTORE(batchHashPos)
    E                                   :MSTORE(batchHashDataId)
    $ => A                              :MLOAD(lastCtxUsed)
    A                                   :MSTORE(ctxTxToUse) ; Points at first context to be used when processing transactions
    
    $${var p = 0}
    
    txLoopRLP:
    $ => A          :MLOAD(lastCtxUsed)
    A+1 => CTX      :MSTORE(lastCtxUsed)
    
    $ => A          :MLOAD(batchL2DataLength)
    $ => C          :MLOAD(batchL2DataParsed)
    C - A           :JMPN(loadTx_rlp, endCheckRLP)
    endCheckRLP:
    :JMP(txLoop)
\end{zkasm}

The first three lines will prepare the Keccak hash instance to compute the hash digest of all transaction data in the batch. It takes and stores in the memory a \textbf{batchHashDataId} based on the last hash ID used. Also, \textbf{batchHashPos} will be set to zero since it will be the pointer of the Keccak input that will be incremented with each transaction addition to the hash input.

Then the variable \textbf{ctxTxToUse} will be set to the last context used value to create new contexts ahead of older ones for each transaction in the batch.


The lines 9 to 15 are executed in a loop for each transaction in the batch. For each transaction, first, a new memory context will be created. The  variable \textbf{lastCtxUsed} will act as the loop index and will also give a specific context number to each transaction. Note that in each iteration, it will be incremented by 1. Then lines 13 to 15 will check if is the last iteration of the loop by comparing length of parsed batch with non parsed batch. In that case, the loop will break. If not, the \href[]{https://github.com/0xPolygonHermez/zkevm-rom/blob/main/main/load-tx-rlp.zkasm}{\textbf{loadTx\_rlp}} code will be executed, it can be found at the ROM's GitHub repository. It contains the logic to parse a transaction of the batch and store each transaction data value in a specific memory variable of the transaction's memory context. It also pushes the data to the hash of all transactions input.



\subsubsection{D: Loop processing transactions}

The section of main.zkasm that follows iterates again through all transactions in the batch, executing each one of them and applying the changes to the Polygon zkEVM state tree.

\begin{zkasm}
    txLoop:
    $ => A          :MLOAD(pendingTxs)
    A-1 => A        :MSTORE(pendingTxs), JMPN(processTxsEnd)
    
    $ => A          :MLOAD(ctxTxToUse) ; Load first context used by transaction
    A+1 => CTX      :MSTORE(ctxTxToUse),JMP(processTx)
    
    processTxEnd:
    :CALL(updateSystemData)
    processTxFinished:
    $${eventLog(onFinishTx)}   :JMP(txLoop)
    
    processTxsEnd:
\end{zkasm}

The lines 1 to 11 are executed in loop for each transaction. the variable \textbf{pendingTxs} will be the loop index. Note that now in each iteration it decrements by 1, starting from the last value set in the \textbf{pendingTxs} variable (for each transaction parsed by the former executed \textbf{loadTx\_rlp} code, the \textbf{pendingTxs} variable is incremented by one). Line 3 will check if all transactions in the batch are already processed by checking if the \textbf{pendingTxs} variable is less than 0. In that case, the loop will break. If not, the  \href[]{https://github.com/0xPolygonHermez/zkevm-rom/blob/main/main/process-tx.zkasm}{\textbf{process-tx}} code will be executed, it can be found at the ROM's GitHub repository. It contains the logic to process an Ethereum transaction adapted to Polygon zkEVM infrastructure. All the verifications that would be done in the Ethereum network, such as transaction signature verification, chain ID, etc., are also implemented in the \textbf{process-tx} code. Note that thanks to the former ROM's section (C), all transaction data can now be accessed through zkASM memory opcodes without the need to parse the bytes string of the batch's transactions again.

In each iteration of the loop, after processing a specific transaction, the subroutine \textbf{updateSystemData} is called (Line 9). Its code can be found on the ROM's GitHub repository in the \href[]{https://github.com/0xPolygonHermez/zkevm-rom/blob/main/main/utils.zkasm}{utils.zkasm} file. The system contract is a special contract in Polygon zkEVM L2 whose storage contains information about the network. The \textbf{updateSystemData} subroutine is meant to update the total processed transaction counter and the state root mapping in the system contract.

\subsubsection{E: Batch computations}

The section of main.zkasm that follows performs the last computations that have to be done for each batch.

First, it reads the \textbf{LocalExitRoot} of the \textbf{PolygonZkEVMGlobalExitRootL2.sol} contract instance and stores it in \textbf{newLocalExitRoot}, which is a variable meant to contain the computation public parameter \textbf{LocalExitRoot}. Since  \textbf{LocalExitRoot} is a public parameter, once the CI proof will be successfully verified by L1 contracts, this value will be sent to the \textbf{PolygonZkEVMGlobalExitRoot.sol} L1 contract instance to trigger the computation of the new bridge's Global exit root and enable to claim bridge transactions in L1.

\begin{zkasm}
    ;; Get local exit root
    ; Read 'localExitRoot' variable from GLOBAL_EXIT_ROOT_MANAGER_L2 and store
    ; it to the 'newLocalExitRoot' input
    %ADDRESS_GLOBAL_EXIT_ROOT_MANAGER_L2  => A
    %SMT_KEY_SC_STORAGE => B
    %LOCAL_EXIT_ROOT_STORAGE_POS => C
    $ => A                                          :SLOAD
    A                                               :MSTORE(newLocalExitRoot)
    
\end{zkasm}

The next segment will ensure that the length of the input of the Keccak hash of all transaction data matches with the length of the byte array of the transactions given as computation input, i.e., all the transactions of given as computation input are included in the hash computation. Then computes the keccak hash and stores the hash digest in the \textbf{batchHashData} memory variable. This value will ensure the integrity of the batch's transactions data queried from L1.

\begin{zkasm}
    ;; Transactions size verification
    ; Ensure bytes added to compute the 'batchHashData' matches the number of bytes loaded from input
    $ => A                          :MLOAD(batchHashPos)
    $                               :MLOAD(batchL2DataLength), ASSERT
    
    ;; Compute 'batchHashData'
    A => HASHPOS
    $ => E                          :MLOAD(batchHashDataId)
    
    HASHPOS                         :HASHKLEN(E)
    $ => A                          :HASHKDIGEST(E)
    
    A                               :MSTORE(batchHashData)
\end{zkasm}

The last segment will compute the accumulated hash of the batch and store it in the \textbf{newAccInputHash} variable, which is meant to contain the computation public parameter \textbf{newAccInputHash}. The accumulated hash will ensure the integrity of the batch data (transactions, timestamp, globalExitRoot) and that of all its predecessors, as well as the order in which they have been sequenced. The L1 verification contract will check that this value equals that one in its storage to ensure that the exact data queried from L1 has been used to perform the off-chain computations of the batch.

\begin{zkasm}
    ;; Compute 'newAccInputHash'
    0 => HASHPOS
    
    32 => D
    $ => A                          :MLOAD(oldAccInputHash)
    A                               :HASHK(0)
    
    $ => A                          :MLOAD(batchHashData)
    A                               :HASHK(0)
    
    $ => A                          :MLOAD(globalExitRoot)
    A                               :HASHK(0)
    
    8 => D
    $ => A                          :MLOAD(timestamp)
    A                               :HASHK(0)
    
    20 => D
    $ => A                          :MLOAD(sequencerAddr)
    A                               :HASHK(0)
    
    HASHPOS                         :HASHKLEN(0)
    
    $ => C                          :HASHKDIGEST(0)
    C                               :MSTORE(newAccInputHash)
    $${eventLog(onFinishBatch)}
\end{zkasm}



\subsubsection{F: Finalize execution}

The final section of main.zkasm will perform the final steps of ROM's execution, which is to load the values of computation results in the proper registers and set the initial values of some required registers. Then it will jump to the final wait. All of these steps are required to be in the code due to the system's design.

\begin{zkasm}
    ; Set output registers
    $ => D                          :MLOAD(newAccInputHash)
    $ => E                          :MLOAD(newLocalExitRoot)
    $ => PC                         :MLOAD(newNumBatch)
    
    ; Set registers to its initials values
    $ => CTX                        :MLOAD(forkID)
    $ => B                          :MLOAD(oldStateRoot)
    $ => C                          :MLOAD(oldAccInputHash)
    $ => SP                         :MLOAD(oldNumBatch)
    $ => GAS                        :MLOAD(chainID)
    finalizeExecution:
    :JMP(finalWait)
\end{zkasm}





